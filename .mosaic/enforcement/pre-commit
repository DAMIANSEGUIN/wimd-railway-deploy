#!/bin/bash
# .mosaic/enforcement/pre-commit
# Machine-enforceable pre-commit hook - blocks violations
# Install: ln -sf ../../.mosaic/enforcement/pre-commit .git/hooks/pre-commit

set -e

REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

echo "ğŸ”’ MOSAIC ENFORCEMENT GATE - Pre-commit validation"
echo ""

VIOLATIONS=0

# ============================================================================
# GATE 1: No absolute paths in documentation
# ============================================================================
echo "ğŸ“‹ Gate 1: Checking for absolute paths in markdown files..."

ABSOLUTE_PATH_PATTERN="(/Users/|/home/|C:\\\\|/private/)"
STAGED_MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.md$' || true)

if [ -n "$STAGED_MD_FILES" ]; then
  for file in $STAGED_MD_FILES; do
    # Skip files that are documentation ABOUT the rules (not violations OF the rules)
    if [[ "$file" == *"MANDATORY_AGENT_BRIEFING.md" ]] || \
       [[ "$file" == *"SESSION_START_CORRECTNESS.md" ]] || \
       [[ "$file" == *"CROSS_AGENT_PROTOCOL.md" ]]; then
      continue
    fi

    # Check for absolute paths, excluding examples in code blocks or quotes
    if grep -n -E "$ABSOLUTE_PATH_PATTERN" "$file" 2>/dev/null | grep -v "NOT /Users" | grep -v "Example:" | grep -v "âŒ WRONG:"; then
      echo "âŒ VIOLATION: Absolute path found in $file"
      echo "   Rule: Use relative paths only (api/index.py, not /Users/.../api/index.py)"
      echo "   Reference: .ai-agents/CROSS_AGENT_PROTOCOL.md Rule 1"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [ $VIOLATIONS -eq 0 ]; then
  echo "âœ… No absolute paths in markdown files"
fi

# ============================================================================
# GATE 2: Context manager pattern in Python files
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 2: Checking Python context manager pattern..."

STAGED_PY_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

if [ -n "$STAGED_PY_FILES" ]; then
  for file in $STAGED_PY_FILES; do
    # Check for incorrect pattern: conn = get_conn()
    if grep -n "conn = get_conn()" "$file" 2>/dev/null | grep -v "with get_conn() as conn"; then
      echo "âŒ VIOLATION: Incorrect database pattern in $file"
      echo "   Found: conn = get_conn()"
      echo "   Required: with get_conn() as conn:"
      echo "   Reference: TROUBLESHOOTING_CHECKLIST.md Context Manager Pattern"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [ $VIOLATIONS -eq 0 ]; then
  echo "âœ… Context manager pattern correct"
fi

# ============================================================================
# GATE 3: PostgreSQL syntax (not SQLite)
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 3: Checking for SQLite syntax in Python files..."

if [ -n "$STAGED_PY_FILES" ]; then
  for file in $STAGED_PY_FILES; do
    # Check for SQLite placeholder syntax
    if grep -n "execute.*?" "$file" 2>/dev/null | grep -v "%s" | grep -v "# OK:" | grep -v "\"\"\""; then
      echo "âš ï¸  WARNING: Possible SQLite syntax (?) found in $file"
      echo "   PostgreSQL uses %s placeholders, not ?"
      echo "   Review: $file"
      # Don't block, just warn (might be false positive)
    fi

    # Check for SQLite AUTOINCREMENT
    if grep -n "AUTOINCREMENT" "$file" 2>/dev/null; then
      echo "âŒ VIOLATION: SQLite AUTOINCREMENT syntax in $file"
      echo "   PostgreSQL uses SERIAL, not AUTOINCREMENT"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  done
fi

if [ $VIOLATIONS -eq 0 ]; then
  echo "âœ… No SQLite syntax violations"
fi

# ============================================================================
# GATE 4: State file schema validation
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 4: Validating .mosaic/*.json schema..."

# Check if jq is available
if command -v jq &> /dev/null; then
  # Validate agent_state.json
  if git diff --cached --name-only | grep -q ".mosaic/agent_state.json"; then
    if ! jq empty .mosaic/agent_state.json 2>/dev/null; then
      echo "âŒ VIOLATION: .mosaic/agent_state.json is not valid JSON"
      VIOLATIONS=$((VIOLATIONS + 1))
    else
      # Check required fields (last_commit removed due to circular dependency)
      for field in version last_agent last_mode current_agent current_task handoff_message; do
        if ! jq -e ".$field" .mosaic/agent_state.json &>/dev/null; then
          echo "âŒ VIOLATION: Missing required field '$field' in .mosaic/agent_state.json"
          VIOLATIONS=$((VIOLATIONS + 1))
        fi
      done
    fi
  fi

  # Validate blockers.json
  if git diff --cached --name-only | grep -q ".mosaic/blockers.json"; then
    if ! jq empty .mosaic/blockers.json 2>/dev/null; then
      echo "âŒ VIOLATION: .mosaic/blockers.json is not valid JSON"
      VIOLATIONS=$((VIOLATIONS + 1))
    fi
  fi

  if [ $VIOLATIONS -eq 0 ]; then
    echo "âœ… State files are valid JSON"
  fi
else
  echo "âš ï¸  WARNING: jq not installed, skipping JSON validation"
fi

# ============================================================================
# GATE 5: Agent state must be updated in each session
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 5: Checking if agent state was updated this session..."

if git diff --cached --name-only | grep -q "^api/\|^mosaic_ui/\|^scripts/.*\.py$"; then
  # Code changes were made
  if ! git diff --cached --name-only | grep -q ".mosaic/agent_state.json"; then
    echo "âš ï¸  WARNING: Code changes detected but .mosaic/agent_state.json not updated"
    echo "   Did you update the state file with your work?"
    echo "   Consider: update last_commit, handoff_message, implementation_progress"
    # Don't block, just warn
  else
    echo "âœ… Agent state updated"
  fi
else
  echo "âœ… No code changes (state update not required)"
fi

# ============================================================================
# GATE 6: No secrets in commits
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 6: Checking for secrets in commits..."

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM || true)
SECRET_PATTERNS=(
  "OPENAI_API_KEY.*sk-[a-zA-Z0-9]+"
  "CLAUDE_API_KEY.*sk-ant-[a-zA-Z0-9]+"
  "DATABASE_URL.*postgresql://.*:[^@]+@"
  "password.*=.*['\"][^'\"]+['\"]"
  "api[_-]?key.*=.*['\"][^'\"]+['\"]"
)

for pattern in "${SECRET_PATTERNS[@]}"; do
  for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
      # Skip the enforcement hook itself (it defines patterns)
      if [[ "$file" == *"/enforcement/pre-commit" ]]; then
        continue
      fi

      # Check for secrets, excluding examples, documentation, and os.getenv calls
      if grep -i -n -E "$pattern" "$file" 2>/dev/null | grep -v "REDACTED" | grep -v "dummy" | grep -v "example" | grep -v "your_key_here" | grep -v "sk-xxx" | grep -v "sk-ant-xxx" | grep -v "os.getenv" | grep -v "os.environ"; then
        echo "âŒ VIOLATION: Possible secret found in $file"
        echo "   Pattern: $pattern"
        echo "   Never commit API keys, passwords, or connection strings"
        VIOLATIONS=$((VIOLATIONS + 1))
      fi
    fi
  done
done

if [ $VIOLATIONS -eq 0 ]; then
  echo "âœ… No secrets detected"
fi

# ============================================================================
# GATE 7: Commit message format (if provided)
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 7: Checking commit message format..."

COMMIT_MSG_FILE="$REPO_ROOT/.git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
  COMMIT_MSG=$(head -n 1 "$COMMIT_MSG_FILE")

  # Check for conventional commit format
  if ! echo "$COMMIT_MSG" | grep -qE "^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?:.+"; then
    echo "âš ï¸  WARNING: Commit message doesn't follow conventional format"
    echo "   Found: $COMMIT_MSG"
    echo "   Expected: type(scope): message"
    echo "   Types: feat, fix, docs, style, refactor, test, chore"
    # Don't block, just warn
  else
    echo "âœ… Commit message follows conventional format"
  fi
fi

# ============================================================================
# GATE 8: Gemini cross-agent approval (for handoffs)
# ============================================================================
echo ""
echo "ğŸ“‹ Gate 8: Checking for Gemini cross-agent approval..."

# Check if this commit looks like a handoff (agent_state.json being updated)
if git diff --cached --name-only | grep -q ".mosaic/agent_state.json"; then
  # Check if gemini_approval.json exists and is recent
  GEMINI_APPROVAL_FILE=".mosaic/gemini_approval.json"

  if [ ! -f "$GEMINI_APPROVAL_FILE" ]; then
    echo "âš ï¸  WARNING: No Gemini approval found for this handoff"
    echo ""
    echo "   You should run: python3 .mosaic/enforcement/gate_4_gemini_eval.py"
    echo "   to get Gemini's cross-agent evaluation before committing."
    echo ""
    echo "   Proceeding without Gemini approval (not enforced yet)"
    # Don't block yet - grace period to allow testing
  else
    # Check verdict
    if command -v jq &> /dev/null; then
      VERDICT=$(jq -r .verdict "$GEMINI_APPROVAL_FILE" 2>/dev/null || echo "UNKNOWN")

      if [ "$VERDICT" == "APPROVE" ]; then
        echo "âœ… Gemini approved (verdict: APPROVE)"
      elif [ "$VERDICT" == "REQUEST_CHANGES" ]; then
        echo "âš ï¸  WARNING: Gemini verdict is REQUEST_CHANGES"
        echo ""
        echo "   Gemini feedback:"
        jq -r .feedback "$GEMINI_APPROVAL_FILE" 2>/dev/null || true
        echo ""
        echo "   Required fixes:"
        jq -r '.required_fixes[]' "$GEMINI_APPROVAL_FILE" 2>/dev/null || true
        echo ""
        echo "   Fix these issues and run gate_4_gemini_eval.py again"
        echo "   Proceeding anyway (enforcement not strict yet)"
        # Don't block yet - grace period
      elif [ "$VERDICT" == "REJECT" ]; then
        echo "âŒ WARNING: Gemini verdict is REJECT"
        echo ""
        echo "   Gemini feedback:"
        jq -r .feedback "$GEMINI_APPROVAL_FILE" 2>/dev/null || true
        echo ""
        echo "   You should address Gemini's concerns before committing"
        echo "   Proceeding anyway (enforcement not strict yet)"
        # Don't block yet - grace period
      else
        echo "âš ï¸  WARNING: Unknown Gemini verdict: $VERDICT"
      fi
    else
      echo "âœ… Gemini approval file exists (cannot verify without jq)"
    fi
  fi
else
  echo "âœ… Not a handoff commit (Gemini approval not required)"
fi

# ============================================================================
# FINAL VERDICT
# ============================================================================
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

if [ $VIOLATIONS -gt 0 ]; then
  echo "âŒ COMMIT BLOCKED: $VIOLATIONS violation(s) found"
  echo ""
  echo "Fix the violations above and try again."
  echo ""
  echo "To bypass this hook (NOT RECOMMENDED):"
  echo "  git commit --no-verify -m \"message\""
  echo ""
  echo "References:"
  echo "  - .ai-agents/CROSS_AGENT_PROTOCOL.md (7 rules)"
  echo "  - TROUBLESHOOTING_CHECKLIST.md (code patterns)"
  echo "  - .mosaic/MANDATORY_AGENT_BRIEFING.md (prohibitions)"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  exit 1
else
  echo "âœ… ALL GATES PASSED - Commit allowed"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  exit 0
fi
