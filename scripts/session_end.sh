#!/bin/bash
# Session End - Automated State Capture
# Run this at the end of every AI session

set -e

PROJECT_ROOT="/Users/damianseguin/AI_Workspace/WIMD-Railway-Deploy-Project"
cd "$PROJECT_ROOT"

echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘              SESSION END - STATE CAPTURE                       â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# Detect agent
AGENT_NAME="${AI_AGENT_NAME:-Unknown}"
if [ "$AGENT_NAME" = "Unknown" ]; then
    echo "Which AI agent? (claude-code/gemini/cursor)"
    read -r AGENT_INPUT
    case "$AGENT_INPUT" in
        claude*|Claude*) AGENT_NAME="Claude-Code" ;;
        gemini|Gemini) AGENT_NAME="Gemini" ;;
        cursor|Cursor) AGENT_NAME="Cursor" ;;
        *) AGENT_NAME="$AGENT_INPUT" ;;
    esac
fi

TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
CURRENT_BRANCH=$(git branch --show-current)
LAST_COMMIT=$(git log -1 --oneline 2>/dev/null || echo "No commits")
UNCOMMITTED=$(git status --porcelain | wc -l | tr -d ' ')

# Get work summary
echo "What were you working on? (one line summary)"
read -r WORK_SUMMARY

echo ""
echo "Status: (done/in-progress/blocked)"
read -r STATUS

BLOCKER=""
NEXT_STEPS=""
if [ "$STATUS" = "blocked" ]; then
    echo "What's blocking? (one line)"
    read -r BLOCKER
fi

if [ "$STATUS" != "done" ]; then
    echo "Next steps for next session? (one line)"
    read -r NEXT_STEPS
fi

# Check backend health
echo ""
echo "Checking backend health..."
HEALTH_STATUS=$(curl -s -m 5 https://what-is-my-delta-site-production.up.railway.app/health 2>/dev/null | grep -o '"ok":[^,}]*' | cut -d':' -f2 || echo "unknown")

# Get latest handoffs
LATEST_HANDOFFS=$(ls -t .ai-agents/*.md 2>/dev/null | head -3 | xargs -I {} basename {} | paste -sd ',' -)

# Create AI_RESUME_STATE.md
cat > AI_RESUME_STATE.md <<EOF
# AI SESSION RESUME STATE
**Last Updated:** $TIMESTAMP
**Last Agent:** $AGENT_NAME
**Generated by:** scripts/session_end.sh

---

## QUICK START (Copy this to new AI)

**Short prompt:**
\`\`\`
Read AI_RESUME_STATE.md then run ./scripts/show_latest_context.sh and choose option 2
\`\`\`

**If that fails, use detailed prompt at bottom of this file.**

---

## LAST SESSION SUMMARY

**Agent:** $AGENT_NAME
**Work:** $WORK_SUMMARY
**Status:** $STATUS
**Branch:** $CURRENT_BRANCH
**Last Commit:** $LAST_COMMIT
**Uncommitted Files:** $UNCOMMITTED

$([ "$STATUS" = "blocked" ] && echo "**ğŸš¨ BLOCKER:** $BLOCKER" || echo "")
$([ -n "$NEXT_STEPS" ] && echo "**Next Steps:** $NEXT_STEPS" || echo "")

---

## CURRENT STATE

**Modified Files:**
$(git status --short | head -10 || echo "None")
$([ "$UNCOMMITTED" -gt 10 ] && echo "... and $((UNCOMMITTED - 10)) more files" || echo "")

**Recent Commits (last 5):**
$(git log --oneline -5 2>/dev/null)

**Backend Health:** $HEALTH_STATUS

**Recent Handoffs:**
$LATEST_HANDOFFS

---

## CRITICAL ISSUE TRACKER

$([ "$STATUS" = "blocked" ] && echo "ğŸš¨ **ACTIVE BLOCKER:** $BLOCKER" || echo "âœ… No active blockers")

**Known Issues from Handoffs:**
$(ls -t .ai-agents/CLAUDE_HANDOFF*.md .ai-agents/GEMINI*.md 2>/dev/null | head -1 | xargs grep -h "CRITICAL\|BLOCKER\|ğŸš¨" 2>/dev/null | head -5 || echo "None")

---

## NEXT SESSION CHECKLIST

When starting next session:
1. âœ… Read this file (AI_RESUME_STATE.md)
2. âœ… Run: ./scripts/show_latest_context.sh (choose option 2)
3. âœ… Check backend health
4. âœ… Review modified files above
5. âœ… Address blocker if present
6. âœ… Continue work or start next task

---

## DETAILED CONTEXT (Use if short prompt fails)

**If AI doesn't understand short prompt, use this:**

\`\`\`
You are $AGENT_NAME starting a new session.

IMMEDIATE CONTEXT:
- Previous agent: $AGENT_NAME
- Last worked on: $WORK_SUMMARY
- Status: $STATUS
$([ "$STATUS" = "blocked" ] && echo "- BLOCKER: $BLOCKER" || echo "")
- Branch: $CURRENT_BRANCH
- Uncommitted changes: $UNCOMMITTED files

CRITICAL TASKS:
$([ -n "$NEXT_STEPS" ] && echo "1. $NEXT_STEPS" || echo "1. Review recent handoffs for next task")
2. Check latest handoff documents in .ai-agents/
3. Review git status and modified files

SYSTEM STATUS:
- Backend health: $HEALTH_STATUS
- Latest handoffs: $LATEST_HANDOFFS

FILES TO READ:
- This file (AI_RESUME_STATE.md) - you're reading it now
- Latest handoff: $(ls -t .ai-agents/*.md 2>/dev/null | head -1 || echo "None")
- CLAUDE.md - main project documentation

RUN THIS NEXT:
./scripts/show_latest_context.sh
Then choose option 2 to see latest handoff documents.

AFTER LOADING CONTEXT:
Ask the user: "Context loaded. Should I continue with: $WORK_SUMMARY?"
\`\`\`

---

**Last session ended:** $TIMESTAMP
**Next agent: Run ./scripts/show_latest_context.sh**
EOF

echo ""
echo "âœ… State captured in AI_RESUME_STATE.md"
echo ""

# Create handoff manifest
HANDOFF_FILE=".ai-agents/handoff_$(date +%Y%m%d_%H%M%S).json"
./scripts/create_handoff_manifest.sh > "$HANDOFF_FILE" 2>/dev/null || echo "{}" > "$HANDOFF_FILE"

echo "âœ… Handoff manifest created: $HANDOFF_FILE"
echo ""

# Ask about commit
if [ "$UNCOMMITTED" -gt 0 ]; then
    echo "Commit changes now? (y/n)"
    read -r COMMIT_CONFIRM

    if [ "$COMMIT_CONFIRM" = "y" ]; then
        git add -A
        git commit -m "$STATUS: $WORK_SUMMARY

Agent: $AGENT_NAME
Branch: $CURRENT_BRANCH
$([ "$STATUS" = "blocked" ] && echo "Blocker: $BLOCKER" || echo "")
$([ -n "$NEXT_STEPS" ] && echo "Next: $NEXT_STEPS" || echo "")

Session ended: $TIMESTAMP"

        echo ""
        echo "âœ… Changes committed"
    else
        echo "âš ï¸  Changes not committed - remember to commit before deploy"
    fi
fi

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘              SESSION END COMPLETE                              â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Next agent: Read AI_RESUME_STATE.md"
echo ""
